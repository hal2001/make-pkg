#!/usr/bin/env bash

# ---------------
# Run make-pkg --help for brief usage information; see https://github.com/mklement0/make-pkg for more.
#
# Note that this utility lists package 'json' as BOTH a runtime AND a development dependency - THIS IS INTENTIONAL, AND MUST BE KEPT:
# 'json' is this utility's only true *runtime* dependency - it needs that package to run.
# To manage this utility's own package, several more *development* dependencies exist, and 'json' is listed there *as well, by design*, 
# because the list of development dependencies is also copied to the 'package.json' file of projects created by this utility -
# such 'package.json' files initially have no *runtime* dependencies, but the dev tasks implemented in the 'Makefile' file definitely
# rely on 'json' as well.
# `npm install` gives a warning about the seemingly duplicate 'json' entries when run in this utility's package folder, but this can be ignored.
# ---------------

kTHIS_HOMEPAGE='https://github.com/mklement0/make-pkg'
kTHIS_NAME=${BASH_SOURCE##*/} # this script's name
kTHIS_VERSION='v0.7.1' # NOTE: This assignment is automatically updated by `make version VER=<newVer>` - DO keep the 'v' prefix.

unset CDPATH  # To prevent unexpected `cd` behavior.

# --- Begin: STANDARD HELPER FUNCTIONS

die() { echoError "$kTHIS_NAME: ERROR: ${1:-"ABORTING due to unexpected error."}" 1>&2; exit ${2:-1}; }
dieSyntax() { echoError "$kTHIS_NAME: ARGUMENT ERROR: ${1:-"Invalid argument(s) specified."}"$'\n'"Use -h for help." 1>&2; exit 2; }

# SYNOPSIS
#   openUrl <url>
# DESCRIPTION
#   Opens the specified URL in the system's default browser.
openUrl() {
  local url=$1 platform=$(uname) cmd=()
  case $platform in
    'Darwin') # OSX
      cmd=( open "$url" )
      ;;
    'CYGWIN_'*) # Cygwin on Windows; must call cmd.exe with its `start` builtin
      cmd=( cmd.exe /c start '' "$url " )  # !! Note the required trailing space.
      ;;
    'MINGW32_'*) # MSYS or Git Bash on Windows; they come with a Unix `start` binary
      cmd=( start '' "$url" )
      ;;
    *) # Otherwise, assume a Freedesktop-compliant OS, which includes many Linux distros, PC-BSD, OpenSolaris, ...
      cmd=( xdg-open "$url" )
      ;; 
  esac
  "${cmd[@]}" || { echo "Cannot locate or failed to open default browser; please go to '$url' manually." >&2; return 1; }
}

# Prints the embedded Markdown-formatted man-page source to stdout.
printManPageSource() {
  sed -n -e $'/^: <<\'EOF_MAN_PAGE\'/,/^EOF_MAN_PAGE/ { s///; t\np;}' "$BASH_SOURCE"
}

# Opens the man page, if installed; otherwise, tries to display the embedded Markdown-formatted man-page source; if all else fails: tries to display the man page online.
openManPage() {
  local pager embeddedText 
  if ! man 1 "$kTHIS_NAME" 2>/dev/null; then
    # 2nd attempt: if present, display the embedded Markdown-formatted man-page source
    embeddedText=$(printManPageSource)
    if [[ -n $embeddedText ]]; then
      pager='more'
      command -v less &>/dev/null && pager='less' # see if the non-standard `less` is available, because it's preferable to the POSIX utility `more`
      printf '%s\n' "$embeddedText" | "$pager"
    else # 3rd attempt: open the the man page on the utility's website
      openUrl "${kTHIS_HOMEPAGE}/doc/${kTHIS_NAME}.md"
    fi
  fi  
}

# Prints the contents of the synopsis chapter of the embedded Markdown-formatted man-page source for quick reference.
printUsage() {
  local embeddedText
  # Extract usage information from the SYNOPSIS chapter of the embedded Markdown-formatted man-page source.
  embeddedText=$(sed -n -e $'/^: <<\'EOF_MAN_PAGE\'/,/^EOF_MAN_PAGE/!d; /^## SYNOPSIS$/,/^#/{ s///; t\np; }' "$BASH_SOURCE")
  if [[ -n $embeddedText ]]; then
    # Print extracted synopsis chapter - remove backticks for uncluttered display.
    printf '%s\n\n' "$embeddedText" | tr -d '`'
  else # No SYNOPIS chapter found; fall back to displaying the man page.
    echo "WARNING: usage information not found; opening man page instead." >&2
    openManPage
  fi
}

# --- End: STANDARD HELPER FUNCTIONS

# ---  PROCESS STANDARD, OUTPUT-INFO-THEN-EXIT OPTIONS.
case $1 in
  --version)
    # Output version number and exit, if requested.
    echo "$kTHIS_NAME $kTHIS_VERSION"$'\nFor license information and more, visit '"$kTHIS_HOMEPAGE"; exit 0
    ;;
  -h|--help)
    # Print usage information and exit.
    printUsage; exit
    ;;
  --man)
    # Display the manual page and exit, falling back to printing the embedded man-page source.
    openManPage; exit
    ;;
  --man-source) # private option, used by `make update-doc`
    # Print raw, embedded Markdown-formatted man-page source and exit
    printManPageSource; exit
    ;;
  --home)
    # Open the home page and exit.
    openUrl "$kTHIS_HOMEPAGE"; exit
    ;;
esac

# ================ BEGIN: Helper functions

# SYNOPSIS
#   rreadlink symlink
# DESCRIPTION
#   Outputs the canonical path of the specified symlink's ultimate target.
#   If the argument is not a symlink, its own canonical path is output.
# NOTES
#   Attempts to use `readlink`, which is found on most modern platforms (notable exception: HP-UX)
#   If `readlink` is not available, output from `ls -l` is parsed, which is the only POSIX-compliant
#   way to determine a symlink's target; caveat: if a filename contains literal ' -> ', this will break.
# THANKS
#   Gratefully adapted from http://stackoverflow.com/a/1116890/45375
rreadlink() ( # execute function in a *subshell* to localize the effect of `cd`.

  local target=$1 fname targetDir readlinkexe=$(command -pv readlink) CDPATH= 

  while :; do # Resolve potential symlinks until the ultimate target is found.
      [[ -L $target || -e $target ]] || { printf '%s\n' "$FUNCNAME: ERROR: '$target' does not exist." >&2; return 1; }
      builtin cd "$(command -p dirname "$target")" # Change to target dir; necessary for correct resolution of target path.
      fname=$(command -p basename "$target") # Extract filename.
      if [[ -L $fname ]]; then
        # Extract [next] target path, which is defined
        # relative to the symlink's own directory.
        if [[ -n $readlinkexe ]]; then # Use `readlink`.
          target=$("$readlinkexe" "$fname")
        else # `readlink` utility not available.
          # Parse `ls -l` output, which is the only POSIX-compliant way
          # to determine a symlink's target.
          target=$(command -p ls -l "$fname")
          target=${target#* -> }
        fi
        continue # Resolve [next] symlink target.
      fi
      break # Ultimate target reached.
  done
  targetDir=$(builtin pwd -P) # Get canonical dir. path
  # Output the ultimate target's canonical path.
  printf '%s\n' "${targetDir%/}/$fname"

)

# SYNOPSIS
#   toJsonArray indent item1 ...
# DESCRIPTION
#   Returns a multi-line JSON array with the specified indentation comprising the specified items.
#   Output always starts with \n.
#   Either pass all values as a single argument, or use multiple ones.
#   - Any item that starts with " or { is assumed to be a preformatted scalar string / object and is printed as is.
#   - Otherwise, the item is assumed to be a scalar and is enclosed in "...", unless it is a Boolean or a decimal number.
#   Separator can be whitespace or comma.
#   If your items contain embedded whitespace, you MUST use comma as the separator.
#   Either way, 
#     - all items are trimmed (leading and trailing whitespace is removed).
#     - empty items are SKIPPED.
#   NOTE: 
#    If at least one comma is found in the items, the entire argument list is split by comma.
#    To test if the array is empty, use [[ $jsonArr =~ ^[[:space:]]*\[[[:space:]]*\][[:space:]]*$ ]] && echo 'empty'
# EXAMPLES
#   toJsonArray ' ' 'one two three' # -> $'\n [\n     "one"\n   , "two"\n   , "three"\n ]\n'
#   toJsonArray ' ' 'one (1), two (2), three (3)'
toJsonArray() {
  local indent=$1; shift
  local items quoteChar=
  if [[ "$*" == *,* ]]; then # split by comma
    IFS=, read -r -a items <<<"$*"
  else # split by whitespace
    read -r -a items <<<"$*"
  fi
  local countSoFar=0 i item
  printf "\n${indent}[\n"
  for (( i = 0; i < ${#items[@]}; i++ )); do
    read -r item <<<"${items[i]}"  # trim leading and trailing whitespace
    [[ -z $item ]] && continue # skip empty items
    printf "${indent}"
    (( countSoFar++ )) && printf '  , ' || printf '    '
    if [[ $item =~ ^[\"\{] ]]; then # if the item starts with " or {, assume it's a preformatted scalar /object and print as is.
      printf '%s\n' "$item"
    else
      quoteChar=\"
      # Do not quote if the item is a Boolean or a number.
      if [[ $item =~ ^(true|false)$ || $item =~ ^[-+]?[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?$ ]]; then
        quoteChar=
      fi
      printf '%s%s%s\n' "$quoteChar" "$item" "$quoteChar"
    fi
  done
  printf "${indent}]\n"
}

# SYNOPSIS
#   toJsonObject indent keyValuePair1 ...
# DESCRIPTION
#   Returns a multi-line JSON object with the specified indentation comprising the specified key-value pairs.
#   Each key-value pair is assumed to be preformatted as valid JSON.
# EXAMPLES
#   toJsonObject ' ' '"one": 1' '"two": "zwei"' # -> $'\n {\n     "one": 1\n   , "two": "zwei"\n }\n'
toJsonObject() {
  local indent=$1; shift
  printf "\n${indent}{\n"
  for (( i = 0; i < $#; i++ )); do
    printf "${indent}"
    (( i )) && printf '  , ' || printf '    '
    printf '%s\n' "${@:1+i:1}"
  done
  printf "${indent}}\n"
}

# SYNOPSIS
#          contains [-i -p] needle "${haystack[@]}"  
# Determines if a string is contained in an array of strings; the exit code indicates success.
# -i ... matches case-INsensitively
# -p ... also *prints* the matching element, if any (useful for knowing the true case of an element)
# Thanks, http://stackoverflow.com/questions/3685970/bash-check-if-an-array-contains-a-value
# EXAMPLES
#   a=('one' 'two' 'three')
#   contains 'two' "${a[@]}"   && echo 'YES' # -> 'YES'; $? returns 0
#   contains -i 'TWO' "${a[@]}"   && echo 'YES' # -> 'YES'; $? returns 0
#   contains -ip 'TWO' "${a[@]}" # -> 'two'; $? returns 0
contains() ( # run in subshell to localize effect of shopt
  # Process *options*.
  local opt printElem=0 caseInsensitive=0 OPTARG= OPTIND=1
  while getopts 'pi' opt; do
    case "$opt" in
      '?') # unknown option
        return 2
        ;;
      p)
        printElem=1
        ;;
      i)
        shopt -s nocasematch
        ;;
    esac
  done
  shift $((OPTIND - 1)) # Skip the already-processed arguments (options).

  local el needle=$1; shift
  for el; do [[ "$el" == "$needle" ]] && { (( printElem )) && printf '%s\n' "$el"; return 0; } done
  return 1
)

# SYNOPSIS
#  substrTrueCase needle haystack
# BEGIN
#  Case-INsensitively searches for NEEDLE in HAYSTACK and outputs the string that
#  matches NEEDLE in its *original case*, i.e., in whatever case it happens to be
#  contained in HAYSTACK.
#  If there is no match, nothing is output and the exit code is set to 1.
# EXAMPLES
#   token=$(substrTrueCase 'cd' 'AB,CD') # -> $token == 'CD'
substrTrueCase() ( # run in subshell to localize effect of shopt
  shopt -s nocasematch
  [[ $2 =~ ^(.*)("$1") ]] && printf '%s\n' "${BASH_REMATCH[2]}" || return 1
)

# SYNOPSIS
#   colorOutput colorNum [...]
# DESCRIPTION
#   Prints input in the specified color, which must be an ANSI color code (e.g., 31 for red),
#   Uses stdin, if no arguments are specified.
#   Either way, a trailing \n is NOT added.
#
#   If the variable kNO_COLOR is set, coloring is suppressed.
#   An invoking script may set this in case output is NOT being sent to a terminal
#   (e.g., test -t 1 || kNO_COLOR=1)
# EXAMPLES
#   colorOutput 31 "I'm red"
#   cat file | colorOutput 32 # file contents is printed in green
colorOutput() {
  local pre="\033[${1}m" post='\033[0m'
  (( kNO_COLOR )) && { pre= post=; }
  shift   
  if (( $# )); then
    printf "${pre}%s${post}" "$@"
  else
    printf "$pre"
    cat
    printf "$post"
  fi  
}

# -- The following functions can be used:
#     - with stdin (e.g., "I'm all green" | green)
#     - with arguments, inline (e.g., echo "I am $(blue 'blue')."
#       No trailing \n is added, so you must append one explicitly, if desired.

green() {
   colorOutput 32 "$@"
}

red() {
   colorOutput 31 "$@"
}

blue() {
   colorOutput 34 "$@"
}

yellow() {
   colorOutput 33 "$@"
}
# --

# -- Color-coded printing function for status / warning / error messages.

echoStatus() {
  blue "$@"
  printf '\n'
}

echoWarning() {
  {
    yellow "$@"
    printf '\n'
  } >&2
}

echoError() {
  {
    red "$@"
    printf '\n'
  } >&2
}

# --

# SYNOPIS
#   isDirEmpty dir
# DESCRIPTION
#   Indicates if the specified directory is fully empty (exit code 0) or not (exit code 1).
#   The directory must exist, otherwise an error message is printed and the exit code is set to 3.
#   Fully empty means that hidden items are also considered, with the exception of '.DS_Store' - i.e.,
#   a directory containing only this 1 file is still considered empty. ('.DS_Store' contains view state for the Finder on OSX).
# EXAMPLE
#  isDirEmpty ~/Applications && echo "~/Applications is completely empty."
isDirEmpty() {
  [[ -d "${1:-.}" ]] || { echo "$FUNCNAME: ERROR: Argument not found or not a directory: $1"; return 3; }
  [[ $(shopt -s nullglob dotglob; cd "$1"; echo *) =~ ^$|^\.DS_Store$ ]]
}

# SYNOPSIS
#   isInSubtree fileOrFolder putativeAncestorFolder [childrenOnly]
# DESCRIPTION
#   Indicates if FILEORFOLDER is in the subtree of PUTATIVEANCESTORFOLDER,
#   using case-INsensitive COMPARISON.
#   I.e., tests whether FILEORFOLDER is either a child (direct descendant)
#   or indirect descendant of PUTATIVEANCESTORFOLDER.
#   To restrict matching to immediate child items, pass 1 for CHILDRENONLY.
#   Paths are normalized as much as possible, but symlinks are NOT followed.
#   Extant paths are fully normalized, non-extant paths are prefix-normalized.
#   Differences with respect to a terminating / are ignored.
# EXAMPLES
#  isInSubtree /usr/local/bin /usr    # -> exit code 0 # yes, in subtree
#  isInSubtree /usr/local/bin /usr 1  # -> exit code 1 # no, not a direct child
#  isInSubtree . ~                    # -> exit code 0, if current dir. is descendant of home dir.
isInSubtree() {
  local paths=("$1" "$2") childrenOnly=${3:-0}
  for (( i = 0; i < "${#paths[@]}"; i++ )); do
    if [[ -d ${paths[i]} ]]; then # path is extant folder, normalize it.
        paths[i]=$(cd "${paths[i]}"; echo "$PWD")
    elif [[ -d $(dirname "${paths[i]}") ]]; then # parent path exists, normalize it and append last component
      name=$(basename "${paths[i]}"); [[ $name == '/' ]] && name=''
      fldr=$(cd "$(dirname "${paths[i]}")"; echo "$PWD")
      paths[i]=${fldr%/}/$name
    else # non-extant path, perform courtesy prefix normalizations
      case "${paths[i]}" in
        ./*) # replace './' prefix with current dir.
          paths[i]=${PWD%/}/${paths[i]:2}
          ;;
        ../*) # replace '../' prefix with normalized parent dir.
          fldr=$(cd "${PWD%/}/.."; echo "$PWD")
          paths[i]=${fldr%/}/${paths[i]:3}
          ;;
        /*) # already an absolute path, nothing to do.
          ;;
        *) # not an absolute path, prepend current dir.
          paths[i]=${PWD%/}/${paths[i]}
          ;;
      esac
    fi
  done
  if (( childrenOnly )); then
    (shopt -s nocasematch; [[ $(dirname "${paths[0]}") == ${paths[1]} ]])
  else
    (shopt -s nocasematch; [[ ${paths[0]} == "${paths[1]%/}/"* ]])
  fi
}

# SYNOPSIS
#   expandVars text
#   ... | expandVars
# DESCRIPTION
#   Expands (interpolates) a bash string template containing unexpanded shell variable references,
#   based on the current shell environment.
#   NOTE: Only simple variable references are expanded, NOT command or arithmetic substitions.
#         DO escape literal $ instances as \$ in the input.
#         Single \ instances in the input not followed by $ are preserved; however, to preserve 
#         *multiple* adjacent \ chars. you must DOUBLE them in the input.
#         EDGE CASES: 
#           - A variable expansion with an *embedded* command or arithmetic substitution - e.g., 
#            "${HOME:0:`echo 10`}" - will BREAK this function.
#           - A malformed variable expansion - e.g., "${HOME" (missing closing '}') - will
#             BREAK this function.
# EXAMPLES
#   expandVars 'Go $HOME'         # -> 'Go /Users/jdoe'
expandVars() {
  local txtToEval=$*
  # If no arguments were passed, process stdin input.
  (( $# == 0 )) && IFS= read -r -d '' txtToEval
  # Disable command substitutions and arithmetic expansions to prevent execution
  # of arbitrary commands.
  # If you fully trust or control the input, you can disable these statements.
  # Note that selectively allowing $((...)) or $[...] to enable arithmetic
  # expressions is NOT safe, because command substitutions could be embedded in them.
  txtToEval=${txtToEval//\`/\\\`}    # disable `...`
  txtToEval=${txtToEval//\$(/\\\$(}  # disable both $(...) and $((...))
  txtToEval=${txtToEval//\$[/\\\$[}  # disable $[...] 
  # Pass the string to `eval`, escaping embedded double quotes first.
  # `printf %s` ensures that the string is printed without interpretation
  # (after processing by by bash).
  eval printf %s "\"${txtToEval//\"/\\\"}\""   # " <- the sole purpose of this is to fix a bug with syntax highlighting in ST.
}

# SYNOPSIS
#   expandTemplate [-O [-d] [-n]] [-s] file ...
#   expandTemplate  -O [-d] [-n]  [-s] fileOrDir ...
#   expandTemplate [-s]
# DESCRIPTION
#   Expands (interpolates) the contents of template files containing unexpanded variable references,
#   command substitutions, and arithmetic expansions, based on the current shell environment.
#   Optionally, expansions can be limited to variable references only.
#   Without filename operands, input is read from stdin (even interactively *all* input is read at once).
#   
#   NOTE: Only the $(...) form of command substitution is recognized - `...` sequences are IGNORED.
#         This reduces the likelhood of accidental expansion, especially with Markdown input.
#         Do NOT escape ` instances in the input.
#         DO escape literal $ instances as \$ in the input.
#         Single \ instances in the input not followed by $ are preserved; however, to preserve 
#         *multiple* adjacent \ chars. you must DOUBLE them in the input.
#         !! SINCE DOUBLE QUOTES MUST BE ESCAPED BEFORE EVALUATION, DO NOT USE DOUBLE QUOTES
#         !! INSIDE COMMAND SUBSTITUTIONS - THAT WILL RESULT IN THE DOUBLE QUOTES GETTING PRESERVED
#         !! AND THE CONTENTS OF THE STRING GETTING EXPANDED, INCLUDING WHITESPACE NORMALIZATION; 
#         !! INSTEAD, USE PRINTF %Q ON THE STRING TO QUOTE AND USE THE \-ESCAPED VERSION.
#         EDGE CASES:
#           - A variable expansion with an (unsupported) *embedded* backticks command substitution
#             - e.g., "${HOME:0:`echo 10`}" - will BREAK this function.
#             With -s, *any* command or arithmetic substitution embedded in a variable expansion
#             will break.
#           - A malformed variable expansion - e.g., "${HOME" (missing closing '}') - will
#             BREAK this function.
#
#   Outputs the expanded result to stdout by default.
#   With -O, the path of [each] file created is printed instead.
#
#   -s
#     Safe mode: only variable references are expanded, not command substitutions or arithmetic expansions.
#   -O
#     Requires input files named *.tmpl or *.tmpl(<someOtherExt>)+: saves the expansion results back to files 
#     in the same dir. named just * or *.(<someOtherExt>)+ (i.e., the '.tmpl' is removed from the filename part).
#     You may specify *directories* instead of input files, in which case all matching template files in a given
#     directory's *subtree* are processed.
#     Note that matching '.tmpl' is case-SENSITIVE and that the *filename* of each template file is also
#     expanded - be sure that the expansion results in a valid filename.
#     If a template file is executable, the expanded file will be made executable too.
#     CAUTION: Existing output files are by default silently replaced, unless -n is specified.
#     -d 
#      On successful expansion and creation of the output file, DELETES the INPUT file.
#      CAUTION: Only use this if you've *cloned* the master templates first and are now passing in *cloned* templates
#      that are no longer needed after expansion.
#     -n
#       Preserves existing target files (does not overwrite them). 
# CAVEATS
#   - CAUTION: Unless you use -s: UNSAFE, ONLY USE WITH TRUSTED INPUT - any embedded $(...) command substitutions 
#            and arithmetic expansions - $((...)) or $[...] - are blindly executed.
#   - Each file processed is read into memory as a whole.
# EXAMPLES
#   expandTemplate <<<'Go $HOME.' # -> 'Go /Users/jdoe.'
#   expandTemplate -O *.tmpl.*  # expand templates and save to filenames without '.tmpl'
#   expandTemplate -O .   # expand all templates and save to filenames without '.tmpl' in entire subtree of current dir.
expandTemplate() {
  local safe=0 toFiles=0 deleteTemplatesAfter=0 noOverwrite=0 f files allFiles txtToEval outFile tmpFile kTMPL_EXT='.tmpl'
  local tmplFnameRegex='[^/.]'"${kTMPL_EXT/./\.}"'(\.[^./][^ /]*)?$' # regex that matches template filenames
  # -- argument processing
  OPTARG= OPTIND=1 # !! Required, if `getopts` was previously called in the current shell.
  while getopts ':sOdn' opt; do  # $opt will receive the option *letters* one by one; a trailing : means that an arg. is required.
    case "$opt" in
      '?')
        { echo "ARGUMENT ERROR: Unknown option: -$OPTARG" >&2; return 2; }
        ;;
      's')
        safe=1
        ;;
      'O')
        toFiles=1
        ;;
      'd')
        deleteTemplatesAfter=1
        ;;
      'n')
        noOverwrite=1
        ;;
    esac
  done
  shift $((OPTIND - 1)) # Skip the already-processed arguments (options).
  (( (deleteTemplatesAfter || noOverwrite) && !toFiles )) && { echo 'ARGUMENT ERROR: Incompatible options specified.' >&2; return 2; }
  if (( $# == 0 )); then # Stdin input.
    (( toFiles )) && { echo 'ARGUMENT ERROR: Incompatible arguments specified.' >&2; return 2; }
    tmpFile=$(mktemp -t 'XXXX') # Works on both OSX and Linux; note: file will have random extension on OSX (e.g., '.../XXXX.bJViLcM3') and none on Linux (e.g., '.../vXDA')
    cat > "$tmpFile"
    allFiles=( "$tmpFile" )
  else
    # -- Pre-process files and dirs. to validate filenames and expand dirs. to indiv. matching files to get an all-files array.
    allFiles=()
    for f; do
      if [[ -f $f || -p $f ]]; then
        if (( toFiles )); then
          [[ $f =~ $tmplFnameRegex ]] || { echo "ERROR: Unexpected input filename; requires '.tmpl' as a filename extension (needn't be the last): $f" >&2; return 1; }
        fi
        allFiles+=( "$f" )
      elif [[ -d $f ]]; then
        (( toFiles )) || { echo "ERROR: To specify a directory, you must also use -O: $f" >&2; return 1; }
        files=()
        IFS=$'\n' read -d '' -ra files < <(find "$f" -type f | egrep "$tmplFnameRegex")
        (( ${#files[@]} > 0 )) || { echo "ERROR: No template files found in directory subtree: $f" >&2; return 1; }
        allFiles+=( "${files[@]}" )
      else
         { echo "ERROR: Not found or neither a file nor a directory: $f" >&2; return 1; }
      fi
    done
  fi
  # -- Perform expansion.
  for f in "${allFiles[@]}"; do
    txtToEval=
    IFS= read -r -d '' txtToEval < "$f" # !! Curiously, this command returns exit code 1, even if it succeeds. Adding a trailing NUL to the input would fix that, but is not worth it.
    [[ -n $txtToEval ]] || { echo "ERROR: Cannot read file or file is empty: $f" >&2; return 1; }
    txtToEval=${txtToEval//\`/\\\`}   # Escape backticks, because we do NOT want them to be interpreted as command substitutions.
    if (( safe )); then # Safe mode: only expand variables -> disable command and arithmetic substitutions.
      txtToEval=${txtToEval//\$(/\\\$(}  # disable both $(...) and $((...))
      txtToEval=${txtToEval//\$[/\\\$[}  # disable $[...] 
    fi
    txtToEval=${txtToEval//\"/\\\"}   # Escape " chars., because " is used to enclose the overall input string inside the command passed to eval below.
    if (( toFiles )); then
      # Synthesize the output filename: same as input path, but with '.tmpl' removed.
      # Note that we also *expand* the resulting filename (but not its path component).
      outFile=$(eval printf %s "\"$(basename "$f" "$kTMPL_EXT")\""); outFile=${outFile/$kTMPL_EXT./.}; outFile="$(dirname "$f")/$outFile"
      if (( noOverwrite )) && [[ -f $outFile ]]; then
        echo "(Existing file preserved: $outFile)" >&2
      else
        eval printf %s "\"${txtToEval}\"" > "$outFile" || { echo "ERROR: Expansion of '$f' to '$outFile' failed." >&2; rm -f "$outFile"; return 1; }
        # If the input template is executable, make the output file executable too.
        [[ -x $f ]] && { chmod +x "$outFile" || { echo "ERROR: Failed to make '$outFile' executable." >&2; return 1; }; }
        echo "$outFile"  # Echo the path of each output file created as status output.
      fi
      (( deleteTemplatesAfter )) && { rm "$f" || echo "WARNING: Failed to delete input file: $f" >&2; }
    else # Output expanded result to stdout.
      eval printf %s "\"${txtToEval}\""
    fi
  done
  [[ -n $tmpFile ]] && rm -f "$tmpFile"
  return 0
}


# SYNOPSIS
#   readPropertyFile file
# DESCRIPTION
#   Reads a Java properties-style file FILE and defines shell-global variables for all properties found.
#   Expected format is <property>=<unquoted-value> - whitespace around '=' is optional; <property> must be a valid bash variable name.
#   Escape sequences are recognized in values; a literal '\' must be escaped as '\\'.
#
#   A # or ! as the first non-whitespace char. on a line marks the line as a comment.
#   Note that in-line comments after values are NOT supported.
#
#   LIMITATIONS and DEVIATIONS from the .properties-file standard:
#      - property names must be valid Bash variable names (matching regex [[:alpha:]_][[:alpha:][:digit:]_]*)
#      - _Trailing_ whitespace is also removed from values, not just leading whitespace.
#      - Spaces cannot be represented as '\ '; to represent a leading or trailing space, use '\040'
#      - Literal newlines in values are not supported; use '\n' to represent line breaks, and other \-escape sequences to represent control chars.
#      - Literal '\' chars. must be represented as '\\'.
#
#   Syntactically invalid lines generate a warning.
#
#   Return value is 0, if at least one variable is successfully read and defined, 1 otherwise.
readPropertyFile() {
  local __rpf_trimmedLine __rpf_key __rpf_value __rpf_atLeastOneRead=0 # Note: since this function sets shell-global variables, we use "namespaced" local variable names to avoid name collisions.
  while read -r __rpf_trimmedLine; do # read line as a whole, but trim leading and trailing whitespace
     # Skip, if empty or comment line.
    [[ -z $__rpf_trimmedLine || $__rpf_trimmedLine =~ ^[\#!] ]] && continue
    # Parse into property name and __rpf_value.
    [[ $__rpf_trimmedLine =~ ^([[:alpha:]_][[:alpha:][:digit:]_]*)[[:blank:]]*=[[:blank:]]*(.*)$ ]] || { echo "WARNING: Ignoring invalid line found in properties file '$1': $__rpf_trimmedLine" >&2; continue; }
    __rpf_key="${BASH_REMATCH[1]}" __rpf_value="${BASH_REMATCH[2]}"
    # Create global shell variable named for the property, with the property's __rpf_value.
    # Note: By using %b, we turn on interpretation of backslash escape sequences.
    if [[ -n $__rpf_value ]]; then # nonempty value found
      printf -v "$__rpf_key" '%b' "$__rpf_value"
    else  # !! printf -v doesn't perform an assignment if the resulting string is the *empty* string.
      eval "$__rpf_key="  # we still want to *create* the variable even if it is *empty*, so `unset $__rpf_key` is not an option; we use `eval`, which is safe to use in this instance.
    fi
    __rpf_atLeastOneRead=1
  done < "$1"
  return $(( __rpf_atLeastOneRead == 0 )) # 0, if at least 1 property was read, 1 otherwise.
}

# SYNOPSIS
#   setProperty file key val
# DESCRIPTION
#   Sets (adds or updates) a property value in a Java-style *.properties file. The file is created on demand.
#
#   VAL is stored in a way that it can later be restored with printf %b.
#   Line breaks and control chars. are encoded as \n and \t, for instance.
#   Literal \ chars. are stored as \\.
#   Leading and trailing whitespace is correctly encoded. To manually represent a leading or trailing space by directly editing
#   the file, use \040
#
#   Caveats:
#     - A new file is created and then renamed, so if the original file was a symlink, it is replaced with a regular file.
#       Updating is unconditional, so the file is rewritten even if it already contained a property with the target value.
#     - Sloow, because the entire file is read line by line.
#
#   LIMITATIONS and DEVIATIONS from the .properties-file standard: see readPropertyFile()
#
# Example:
#   setProperty settings.properties level 1
setProperty() {

  local file=$1 key=$2 newVal=$3 tmpFile line leadingValWhitespace trailingValWhitespace leadingLineWhitespace aKey whitespaceBeforeEqualsSign oldVal escapedNewVal
  local -i updated

  touch "$file" || return # create the target file, if it doesn't exist yet.
  tmpFile=$(mktemp -t 'XXXX') || return # Works on both OSX and Linux; note: file will have random extension on OSX (e.g., '/var/folders/19/0lxcl7hd63d6fqd813glqppc0000gn/T/XXXX.bJViLcM3') and none on Linux (e.g., '/tmp/vXDA')

  # Extract leading and/or trailing *value* whitespace, if any, and strip it.
  [[ $newVal =~ ^(' '+) ]] && leadingValWhitespace=${BASH_REMATCH[1]} && newVal=${newVal#$leadingValWhitespace}
  [[ $newVal =~ [^' ']([ ]+)$ ]] && trailingValWhitespace=${BASH_REMATCH[1]} && newVal=${newVal%$trailingValWhitespace}

  # Determine the single-line encoded (escaped) 
  escapedNewVal=$(printf '%q' "$newVal")
  if [[ $escapedNewVal == "$'"* ]]; then # printf %q returned a $'...' string (this implies the presence of control chars., including newlines) -> strip the delimiter - on reading, printf %b will re-expand the control chars.
    escapedNewVal=${escapedNewVal:2}
    escapedNewVal=${escapedNewVal%?}
  else # printf %q returned a string with *individually* quoted chars. (e.g., '\*'' for *, or '\ ' for ' '): this implies the *absence* of control chars., including newlines
    # We use the string *almost* as is: we need to escape `\` chars. so that they don't get interpreted by printf %b on reading
    escapedNewVal=${newVal//\\/\\\\}
  fi

  [[ -n $leadingValWhitespace ]] && escapedNewVal=${leadingValWhitespace// /\\0040}${escapedNewVal}
  [[ -n $trailingValWhitespace ]] && escapedNewVal=${escapedNewVal}${trailingValWhitespace// /\\0040}

  updated=0
  while IFS= read -r line; do # read line as a whole, unmodified
    if (( ! updated )); then
      # Tokenize line.
      if [[ $line =~ ^([[:blank:]]*)([[:alpha:]_][[:alpha:][:digit:]_]*)([[:blank:]]*)=[[:blank:]]*(.*)$ ]]; then
        leadingLineWhitespace=${BASH_REMATCH[1]} aKey=${BASH_REMATCH[2]} whitespaceBeforeEqualsSign=${BASH_REMATCH[3]} oldVal=${BASH_REMATCH[4]}
        if [[ "$key" == "$aKey" ]]; then # target key found, update the line
          printf '%s%s%s=%s%s\n' "$leadingLineWhitespace" "$key" "$whitespaceBeforeEqualsSign" "$whitespaceBeforeEqualsSign" "$escapedNewVal"
          updated=1
          continue
        fi
      fi
    fi
    printf '%s\n' "$line"
  done < "$file" > "$tmpFile" || return

  if (( updated )); then
    mv -f "$tmpFile" "$file" || return # Replace the original file with the temp. one.
  else # key doesn't exist yet? simply append directly to the original file.
     rm -f "$tmpFile"
     printf '%s=%s\n' "$key" "$escapedNewVal" >> "$file" || return
  fi

  return 0
}

# Given a URL, returns the URL's domain in reverse notation
# EXAMPLE
#   getReverseDomainName 'http://www.same2u.net/news' # -> 'net.same2u'
getReverseDomainName() {
  local url=$1 components i result
  url=${url/#http:\/\/}
  url=${url/#https:\/\/}
  url=${url/#www.}
  url=${url%%/*}
  IFS='.' read -ra components <<<"$url"
  for (( i = ${#components[@]} - 1; i > 0; i-- )); do
    result+="${components[i]}."
  done
  result+="${components[i]}"
  printf '%s\n' "$result"
}

# SYNOPSIS
#   editSettings file templateFile
# DESCRIPTION
#   Opens the specified file for modal editing in the system's visual editor, optionally creating the file by cloning the specified template beforehand.
editSettings() {
  local file=$1 templateFile=$2
  # Copy the settings-file template to the user's home dir., if it doesn't exist there yet.
  if [[ ! -f $file ]]; then
    cp "$templateFile" "$file" || die "Failed to copy settings file template $templateFile to your home directory as $file."
  fi
  "${EDITOR:-vi}" "$file"
}

# SYNOPSIS
#   generateGhAuthToken ghUsername descr [scopes]
# DESCRIPTION
#   Creates and outputs an OAuth (authorization) token obtained via GitHub's API v3 for 
#   the specified GitHub username with the specified description and, optionally scopes.
#   SCOPES can be a list of scopes (single argument), and defaults to 'repo' (the ability to access and create both private and public repos),
#   The password is *prompted for*.
# PREREQUISITES
#   The 'json' CLI in the $PATH (npm package 'json' - see https://www.npmjs.com/package/json)
# NOTES
#   A token can have many more fields not covered here - see https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization
generateGhAuthToken() {
  local username=$1 descr=$2 scopes=${3:-repo} arrScopes scopesJson res errMsg token
  # Convert the scopes list to a JSON array-elements list.
  IFS=', ' read -ra arrScopes <<<"$scopes"
  scopesJson=\"${arrScopes[0]}\"
  for scope in "${arrScopes[@]:1}"; do scopesJson+=", \"$scope\""; done
  # Note that curl itself will only fail if something goes wrong fundamentally. If GitHub responds and sends data -
  # even if that data indicates failure - curl reports success.
  res=$(curl -s -u "$username" 'https://api.github.com/authorizations' -d "{ \"scopes\": [ $scopesJson ], \"note\":\"$descr\"}") || return
  token=$(json 'token' <<<"$res") || return
  if [[ -z $token ]]; then
    # Property 'message' contains the error message, optional property 'errors' contains extended error information.
    errMsg=$(json 'message' 'errors' <<<"$res" | tr '\n' ' ')
    echoError "Generating authorization token for user '$username' with description '$descr' and scopes '$scopes' failed:"$'\n\t'"$errMsg"
    return 1
  fi
  printf '%s\n' "$token"
}

# SYNOPSIS
#   createGhRepo username authToken repoName [repoDescription]
# DESCRIPTION
#   Given a valid GitHub authorization token, creates a repository with the specified name and optional description.
#   Uses the GitHub API v3. Note that USERNAME, the GitHub username, is only used for error messages.
#   If a repo by that name already exists, a specific error message is issued, and the exit code is set to 3.
#   Any other error reported by GitHub results in exit code 1.
#   No stdout output is produced.
# PREREQUISITES
#   The 'json' CLI in the $PATH (npm package 'json' - see https://www.npmjs.com/package/json)
createGhRepo() {
  local username=$1 token=$2 name=$3 descr=$4 res id errMsg
  # Note that curl itself will only fail if something goes wrong fundamentally. If GitHub responds and sends data -
  # even if that data indicates failure - curl reports success.
  res=$(curl -s "https://api.github.com/user/repos?access_token=$token" -d "{ \"name\": \"$name\", \"description\": \"${descr//\"/\\\"}\" }") || return
  id=$(json 'id' <<<"$res") || return
  if [[ -z $id ]]; then
    # Property 'message' contains the error message, optional property 'errors' contains extended error information.
    errMsg=$(json 'message' 'errors' <<<"$res" | tr '\n' ' ')
    # !! We want to detect the case where a repo by that name already exists, but, sadly, the "errors.code" field just says "custom".
    # !! We simply search all "errors" properties for the string "already exists".
    if fgrep -iq $'already exists\nalready_exists' <<<"$errMsg"; then
      echoError "GitHub repository '$username/$name' already exists."
      return 3  # special exit code
    else
      echoError "Creating GitHub repository '$username/$name' failed:"$'\n\t'"$errMsg"
      return 1
    fi
  fi
}

# SYNOPSIS
#   toNaturalLanguageList [item1 ...]
# DESCRIPTION
#   Converts items to natural-language list form
#   (in English). Input items must either be supplied as operands,
#   or line by line via stdin.
#   1 item -> "item"
#   2 items -> "item1 and item2"
#   3 or more items -> "item1, item2, and item3"
# EXAMPLES
#   toNaturalLanguageList tic tac toe  # ->  "tic, tac, and toe"
#   a=( 1 2 ); toNaturalLanguageList "${a[@]}"  # ->  "1 and 2"
#   echo $'1\n2' | toNaturalLanguageList  # ->  "1 and 2"
toNaturalLanguageList() {
  local items=( "$@" )
  (( ${#items[@]} == 0 )) && IFS=$'\n' read -d $'\x4' -ra items
  case "${#items[@]}" in
    0)
      return;
      ;;
    1)
      printf "%s\n" "${items[0]}"
      ;;
    2)
      printf "%s and %s\n" "${items[0]}" "${items[1]}"
      ;;
    *)
      printf '%s, ' "${items[@]: 0: ${#items[@]} -1}"
      printf 'and %s\n' "${items[@]: -1}"
      ;;
  esac
}

# SYNOPSIS
#   printf '%s\n' "${subsetOfIds[@]}" | mapKeysToValues "${values[@]}" "${keys[@]}" 
# DESCRIPTION
#   Maps a selection of keys to their corresponding values.
#   Obviously, the values and keys arrays must be of the same length and have
#   the corresponding entries at the same subscripts.
#   Note that the values must come *first* and the input keys must
#   be provided as *separate lines* via *stdin*.
#   An unknown key produces an empty line of output.
# NOTES
#   This is a poor man's version of an associative array, based on parallel arrays of keys and values.
#   True associative arrays in Bash 4+ could make this so much easier.
# EXAMPLE
#   { echo 3; echo 1; } |  mapKeysToValues one two three 1 2 3  # -> $'three\none'
mapKeysToValues() {
  awk '
    FNR==1 { ++fileNdx }
    {
      fileNdx==1 && selKeys[FNR] = $0
      fileNdx==2 && values[FNR] = $0 
      fileNdx==3 && keys[$0] = values[FNR]
    }
    END {
      for (i=1; i<=length(selKeys);++i) print keys[selKeys[i]]
    }
  ' - <(printf '%s\n' "${@: 1:$#/2}") <(printf '%s\n' "${@: 1+$#/2}")
}

# Indicates if the specified name is a legal npm package name.
# Notably, only lowercase characters are allowed.
# See https://docs.npmjs.com/files/package.json#name
isLegalNpmPackageName() {
  local name=$1
  [[ $name =~ ^[._] || $name =~ [[:upper:]] ]] && return 1
  [[ $name =~ ^[a-z0-9._~-]+$ ]] || return 1
  (( ${#name} >= 214 )) && return 1
  return 0
}

# =================== END: Helper functions


# ----- BEGIN: Script-global constants

# Determine this script's folder, resolving the chain of symlinks to ensure that the true package location is found.
kTHIS_FOLDER=$(dirname "$(dirname "$(rreadlink "$BASH_SOURCE")")") # Note: assumes that this script is in a *subfolder* of the package, namely: bin/.
kTEMPLATE_FOLDER="$kTHIS_FOLDER/templates"

# !! Add the CLIs that come with this package's *dependencies* to the $PATH.
# !! Notably, we need this for the `json` CLI, our *runtime* dependency.
PATH="$kTHIS_FOLDER/node_modules/.bin:$PATH"

# The top-level property for 'package.json' in which to embed custom properties.
# !! Do not change this - the Makefile tasks rely on it.
kCUSTOM_PROPERTIES_ROOT='net_same2u'

# The path to the settings file and its template.
kSETTINGS_FILE_TEMPLATE="${kTHIS_FOLDER}/.${kTHIS_NAME}-rc"
kSETTINGS_FILE=${MAKE_PKG_RC:-~/$(basename "$kSETTINGS_FILE_TEMPLATE")}

# The IDs of the OSs supported by Node.js, as reported by `process.platform`.
kOS_IDS=(   'darwin' 'freebsd' 'linux' 'sunos' 'win32'  )
kOS_NAMES=( 'OSX'   'FreeBSD' 'Linux' 'SunOS' 'Windows' ) # !! Due to limitations in the templating system, these array elements mustn't contain whitespace or other chars. that need quoting for the shell.

# We export a variable that indicates to child processes that make-pkg is being run,
# which is helpful for installation-hook scripts that will also
# get invoked when `npm install` is run in the new package folder below (to install dependencies).
# It allows such scripts to distinguish between invocation then (during package initialization)
# and later invocation during actual installation from the npm registry.
export MAKE_PKG_RUNNING=1

# ----- END: Script-global constants

# --- Main body

  # Process *options*.
force=0 edit=0 localOnly=0
while getopts ':lfe' opt; do  # $opt will receive the option *letters* one by one; a trailing : means that an arg. is required, reported in $OPTARG.
  [[ $opt == '?' ]] && dieSyntax "Unknown option: -$OPTARG"
  case "$opt" in
    l)
      localOnly=1
      ;;
    f)
      force=1
      ;;
    e)
      edit=1
      ;;
    *)
      die "DESIGN ERROR: option -$opt not handled." 3
      ;;
  esac
done

shift $((OPTIND - 1)) # Skip the already-processed arguments (options).

# Optional package type.
pkgType=$1; shift

# Test for incompatible options
(( edit && (force || localOnly) )) || [[ $edit -eq 1 && -n $pkgType ]] && dieSyntax "Incompatible options specified."

# Make sure that not too many arguments were specified.
(( $# == 0 )) || dieSyntax "Unexpected argument(s) specified: $*"

if (( ! edit )); then

  # Make sure that this utility is not run from a directory inside its *own* package.
  if [[ "$(pwd -P)" == "$kTHIS_FOLDER" ]] || isInSubtree "$(pwd -P)" "$kTHIS_FOLDER"; then
    die "You mustn't run this utility in a directory inside its own package."
  fi

  if ! isDirEmpty .; then
    (( force )) || die "Aborting, because the current directory is NOT EMPTY."$'\n'"  To force running nonetheless, use -f."
    echoWarning "WARNING: Forced execution in non-empty directory. Existing files are preserved, except for 'package.json'; npm packages may get updated."
  fi

fi

# Ensure that the required utilities are installed.
[[ -n $(command -v git) ]] || die "Executable \`git\` not found. Please make sure that Git is installed - see http://git-scm.com/"
[[ -n $(command -v npm) ]] || die "Executable \`npm\` not found. Please make sure that Node.js is installed - see https://nodejs.org/"

# See if the `hub` utility (https://github.com/github/hub) is installed.
# If it is, we'll use its stored GitHub authorization configuration.
[[ -n $(command -v hub) ]] && haveHubUtil=1 || haveHubUtil=0

# ----- BEGIN: Settings. They are read from the settings file and/or derived from other sources.

editIfNeededAndContinue=$(( ! edit )) #  editIfNeededAndContinue == true means: normal invocation for creating a new package, with on-demand editing of the properties file, if properties are found missing.
while :; do  # dummy loop that enables re-reading the settings after having triggered editing of the settings on demand.

  if (( editIfNeededAndContinue )); then
      
    # Read the settings file, if extant.
    [[ -f $kSETTINGS_FILE ]] && { readPropertyFile "$kSETTINGS_FILE" || die; }

    # If the vAUTHOR setting isn't defined, try to derive it from the global Git configuration.
    if [[ -z $vAUTHOR ]]; then
      vAUTHOR_NAME=$(git config --global user.name)
      vAUTHOR_EMAIL=$(git config --global user.email)
      vAUTHOR=
      if [[ -n $vAUTHOR_NAME && -n $vAUTHOR_EMAIL ]]; then
        vAUTHOR="$vAUTHOR_NAME <$vAUTHOR_EMAIL>${vAUTHOR_WEBSITE:+ (}${vAUTHOR_WEBSITE}${vAUTHOR_WEBSITE:+)}"
      else
        echoWarning $'WARNING: Failed to get your full name and/or email address from your global Git configuration.\nPreferably abort now and fix this in Git, or proceed and hard-code a vAUTHOR value in the settings file.'
      fi
    else # $vAUTHOR is explicitly defined, so we must derive $vAUTHOR_NAME from it (everything before either ' <' or ' (').
      vAUTHOR_NAME=$(sed 's/^\([^<(]*\).*/\1/; s/ \{1,\}$//' <<<"$vAUTHOR")
    fi

    # If the vGITHUB_USERNAME setting isn't defined, try to derive it from the `hub` utility's configuration.
    if [[ -z $vGITHUB_USERNAME || -z $vGITHUB_TOKEN ]]; then
      if [[ $haveHubUtil -eq 1 && -r ~/.config/hub ]]; then
        # Note: 
        #   Sadly, hub doesn't provide a feature to print its configuration.
        #   Also note that this info will only be present if Hub has actually been used at least once to access the GH API, e.g., in the context of `hub create`.
        #   as prompting happens on demand. There is NO explicit command to just authorize.
        #   ~/.config/hub is a YAML file, but we don't want to install a YAML parser just for that, so perform makeshift parsing with Awk.
        [[ -z $vGITHUB_USERNAME ]] && vGITHUB_USERNAME=$(awk -F '[[:space:]-]+' '$2 == "user:" { print $3; exit}' ~/.config/hub 2>/dev/null)
        [[ -z $vGITHUB_TOKEN ]] && vGITHUB_TOKEN=$(awk -F '[[:space:]-]+' '$2 == "oauth_token:" { print $3; exit}' ~/.config/hub 2>/dev/null)
      fi
    fi

    # --- BEGIN: Apply HARD-CODED DEFAULTS to values potentially not defined in the properties file.

    vVERSION=${vVERSION:-0.0.0}  # Note: We start with version 0.0.0, so that `make version VER=...` can be used to set the first true version number.

    # Default to false for the "private" property; i.e., by default, DO mark packages as designed for publishing in the npm registry.
    vPRIVATE=${vPRIVATE:-false}

    # The "preferGlobal" property (whether the package is designed for global installation).
    # Note that we require an *explicit* choice for this property every time, so the value 
    # here doesn't matter, except to implicitly mark the variable as a Boolean.
    vPREFERGLOBAL=false

    # Settings relating to the inclusion of an auto-generated TOC (Table of Contents) to README.md
    vTOC_ON=${vTOC_ON:-true}
    vTOC_TITLE=${vTOC_TITLE:-'**Contents**'}

    # Settings relating to the generation of a man page for CLI packages, based on a Markdown-formatted
    # document that the package's CLI must output when invoked with `--man-source`.
    # !! We default to FALSE, because this feature is so specialized and has many prerequisites
    # !! (embedding a marked-man-friendly Markdown document in the CLI that can be extracted with --man-source).
    vMAN_ON=${vMAN_ON:-false}

    # --- END: Apply HARD-CODED DEFAULTS to values not defined in the properties file.

    # Convert the list of license SPDX IDs into an array.
    IFS=', ' read -r -a vLIC_SPDX_IDs <<<"$vLIC_SPDX_IDs"

    # Check for required settings and prompt for editing the settings file, if any are missing.
    if [[ -z $vGITHUB_USERNAME || -z $vAUTHOR ]]; then
      cat <<EOF
----------
$(printf %s "REQUIRED SETTINGS ARE MISSING from the settings file, $kSETTINGS_FILE." | red)

Typically, this means that you're running this utility for the first time.

Please EDIT THE SETTINGS FILE and supply values at least for those settings
marked "REQUIRED".
Those marked "RECOMMENDED" are not strictly required, but set useful defaults.

You can edit the settings file anytime with \`$kTHIS_NAME -e\`.
----------
EOF
      while :; do
        read -er -p "Would you like to edit it now? (y/N) " val
        [[ -z $val || $val =~ [nN] ]] && { echo "Aborted." | red >&2; exit 2; }
        [[ $val =~ [yY] ]] && break
        echoError "Invalid input. Please try again."
      done
      edit=1 # set flag to trigger editing below

    elif [[ ! -f $kSETTINGS_FILE ]]; then

      cat <<EOF
----------
$(printf %s "INITIALIZE OPTIONAL SETTINGS via the settings file, $kSETTINGS_FILE." | blue)

The settings file doesn't exist yet, which typically means that you're
running this utility for the first time.

While all required settings could be derived from other sources, it's worth
configuring some DEFAULTS: please review and fill in settings as needed,
especially those marked "RECOMMENDED". 

You can edit the settings file anytime with \`$kTHIS_NAME -e\`.
----------
EOF
      while :; do
        read -er -p "Would you like to edit it now? (y/N) " val
        [[ -z $val || $val =~ [nN] ]] && break
        [[ $val =~ [yY] ]] && { edit=1; break; } # set flag to trigger editing below
        echoError "Invalid input. Please try again."
      done

    else 

      edit=0  # Reset the edit flag; needed, if we get here after after editing had to be triggered in a previous pass.

    fi # required-settings check

  fi # (( editIfNeededAndContinue ))

  # If explicitly requested or implicitly needed, open the settings file in
  # a text editor modally now.
  if (( edit )); then
    editSettings "$kSETTINGS_FILE" "$kSETTINGS_FILE_TEMPLATE" || die
    (( editIfNeededAndContinue )) && continue  # re-read the settings and see if all required settings are now defined.
    exit 0  # if editing was explicitly requested, exit now.
  fi

  # As a courtesy, offer to create a GitHub authorization token programmatically.
  if [[ $localOnly -eq 0 && -z $vGITHUB_TOKEN ]]; then
      cat <<EOF
----------
$(printf %s "GENERATE A GITHUB AUTHORIZATION TOKEN" | blue)

TO CREATE REPOS ON GITHUB THAT MATCH THE LOCAL ONES, A
GITHUB AUTHORIZATION TOKEN IS NEEDED, which requires
that you supply your GitHub password as a one-time action - note that 
your password itself will NOT be stored.

You can skip this step by entering nothing and then choosing to skip.
To suppress this prompt in the future, use \`$kTHIS_NAME -l\`.

The generated token - which should be kept secret - will be stored in 
settings file ${kSETTINGS_FILE/#$HOME/~}, which you can edit anytime with \`$kTHIS_NAME -e\`.
----------
EOF
    echo "Please enter your GITHUB PASSWORD on the following line:"
    while :; do
      vGITHUB_TOKEN=$(generateGhAuthToken "$vGITHUB_USERNAME" "$kTHIS_NAME on $HOSTNAME" 'repo')
      if [[ -z $vGITHUB_TOKEN ]]; then # failed
        echoWarning "To manage / create tokens manually, go to https://github.com/settings/tokens"
        read -er -p "(R)etry, (s)kip, or (a)bort (r/s/A)? " val
        [[ -z $val || $val =~ [aa] ]] && { echo "Aborted." | red >&2; exit 2; }
        [[ $val =~ [sS] ]] && break
        [[ $val =~ [rR] ]] && continue
        echoError "Invalid input. Please try again."
      else # Save the generated token in the settings file.
        setProperty "$kSETTINGS_FILE" 'vGITHUB_TOKEN' "$vGITHUB_TOKEN" || die
        break
      fi
    done
    [[ -n $vGITHUB_TOKEN ]] || echoWarning "Since no authorization token could be obtained, no matching repo on GitHub will be created."
  fi

  # Derive the CANDIDATE dev dependencies from *this* script's package - it is assumed to have a SUPERSET of the dev dependencies that any 
  # newly created package needs - UNNEEDED DEPENDENCIES ARE WEEDED OUT BELOW, after the package type has been determined.
  vDEV_DEPENDENCIES=$(json -f "$kTHIS_FOLDER/package.json" -j 'devDependencies')
  [[ -n $vDEV_DEPENDENCIES ]] || die "Failed to determine dev dependencies."

  # DERIVED PACKAGE-SPECIFIC defaults.

  vNAME=$(basename -- "$PWD")    # The package's name: for consistency and simplicity, *invariably* the same as the current directory name.
  vMAIN="${vNAME}.js"            # Main JS module filename - default to the package name + '.js'

  # !! Since the following depend on values the user can change when prompted below, we must defer deriving their values until after the prompts.
  # !! Note how they're defined with SINGLE quotes, as TEMPLATES - to be expanded LATER, via expandVars()
  # !! VARIABLES DEFINED HERE MAY OR MAY NOT BE INCLUDED DIRECTLY IN PACKAGE.JSON - SOME ARE ONLY REFERENCED FROM *TEMPLATES* (*.TMPL FILES) IN THIS PACKAGE.
  # !! DO NOT ASSUME THAT A VARIABLE CAN BE REMOVED JUST BECAUSE ITS VALUE ISN'T USED IN THE CREATION OF package.json
  delayedExpansionVars=( vHOMEPAGE vREPO_URL vBUGS_URL vLIC_URL )
  vHOMEPAGE='https://github.com/${vGITHUB_USERNAME}/${vNAME}'
  vREPO_URL='https://github.com/${vGITHUB_USERNAME}/${vNAME}.git' # Note: The '.git' suffix is seemingly not *required* - even npm's own package doesn't have it - but we include it, as it should be used for commands such as `git add remote`.
  vBUGS_URL='https://github.com/${vGITHUB_USERNAME}/${vNAME}/issues'
  vLIC_URL='https://spdx.org/licenses/${vLIC_SPDX_ID}#licenseText'  # Note: This won't be saved to package.json, but USED IN TEMPLATE FILE "LICENSE.tmpl.md"

  # Package-specific fields that CAN'T BE GUESSED - they must be provided by the user via prompts below.
  vDESCR=          # The package's short, one-line description.
  vKEYWORD_LIST=   # e.g., 'json, CLI, transform'
  vOS_LIST=        # e.g., 'darwin, linux' or '!win32'
  vBIN_LIST=       # e.g., 'cson2json, json2cson'

  break 
done  # while : - dummy loop for potentially re-reading settings after editing

# ----- END: Settings. They are read from the settings file and/or derived from other sources.


# ---- Define variables to prompt for and their default values.

# Prompt definitions (hints); add '(*)' to mandatory fields.
kLIC_PROMPT=$'LICENSE (SPDX ID; e.g., MIT, GPL-3.0,  LGPL-3.0, BSD-3-Clause, Apache-2.0, MPL-2.0, CDDL-1.0, EPL-1.0; "+" suffix for or-later logic, where supported)\n'
kOS_PROMPT='SUPPORTED OSs, separated with ","; exclude with "!" prefix; blank = no restriction (darwin, freebsd, linux, sunos, win32)'
kHINTS=(     'PRIVATE (do not publish to npm registry)?'  'Short (single-line) DESCRIPTION (*)'  'Prefer GLOBAL installation (for CLI-only projects) (*)?'   '"bin" (CLI) entries (filename(s) only, location ./bin implied; separated with "," - optional, if not global)'  'MAIN MODULE *.js file (filename only, location ./lib implied; optional, if global)'   "$kOS_PROMPT"  'KEYWORDS, separated with "," (*)' "$kLIC_PROMPT"  )
kVAR_NAMES=( vPRIVATE                                     vDESCR                                  vPREFERGLOBAL                                               vBIN_LIST                                                                                                       vMAIN                                                                                 vOS_LIST      vKEYWORD_LIST                        vLIC_SPDX_ID )

# -- PACKAGE-TYPE SUPPORT
varPromptsToSkip=()
vPACKAGE_SCRIPTS=( '"test": "make test"' )
vPOSTINIT_CMD=()  # optional command to run post-initialization
case $pkgType in
  '') # no package type specified
    # Present full set of prompts for creating lib and/or CLI npm packages.
    ;;
  cli) # CLI-only package, with global installation preferred
    # Define what prompts should be skipped due to implied defaults...
    varPromptsToSkip=( vPREFERGLOBAL vBIN_LIST vMAIN )
    # ... and define the *implied default values*:
    vPREFERGLOBAL='true'
    vMAIN=
    vBIN_FIRST=$vNAME
    vBIN_MAP=$(toJsonObject '    ' "\"${vBIN_FIRST}\": \"bin/${vBIN_FIRST}\"")
    ;;
  lib) # (JS) library-only package
    # Define what prompts should be skipped due to implied defaults...
    varPromptsToSkip=( vPREFERGLOBAL vBIN_LIST vMAIN )
    # ... and define the *implied default values*:
    vPREFERGLOBAL='false'
    # vMAIN is already initialized
    ;;
  awf) # Alfred 2 workflow packages
    # Check prerequisites
    [[ $vNAME == *'.awf' ]] || die "An Alfred 2 workflow package name must end in '.awf'; please rename the current directory and try again."
    # Note: The check for whether the name is legal as an npm package name happens below - and may be skipped, if the package is marked as private.
    # Specify the post[un]installation scripts that [un]install the workflow from/in Alfred.
    vPACKAGE_SCRIPTS+=( '"postinstall": "./bin/installAwf"' '"postuninstall": "./bin/installAwf -u"' )
    # Define the post-initialization command to run.
    vPOSTINIT_CMD=( ./bin/installAwf --dev-setup )
    # Define what prompts should be skipped due to implied defaults...
    varPromptsToSkip=( vPREFERGLOBAL vBIN_LIST vMAIN vOS_LIST )
    # ... and define the *implied default values*:
    vPREFERGLOBAL='true'
    vMAIN=''
    vOS_JSON_ARRAY=$(toJsonArray '    ' 'darwin') 
    # ... complementarily, define *edit-buffer* defaults that prefill the 
    # prompt buffer to be *complemented/modified by the user*:
    # !! AS OF OSX 10.11.1, when using the AppleScript-based workaround with Bash 3.x,
    # THE keystroke APPLESCRIPT COMMAND IGNORES "." CHARS. AND DIGITS DUE TO A BUG.
    vDESCR_EDITBUFDEFAULT='An Alfred workflow '
    vKEYWORD_LIST_EDITBUFDEFAULT='osx, awf, alfred, workflow, '
    # Add additional, package-type-specific prompts (variables).
    kVAR_NAMES+=( vAWF_BUNDLEID )
    kHINTS+=( 'Workflow BUNDLE ID' )
    vAWF_BUNDLEID="$(getReverseDomainName "$vAUTHOR_WEBSITE").${vNAME}"
    ;;
  *)
    die "Unknown package type specified: $pkgType"
    ;;
esac

# Fill the default-values array using variable indirection.
defVals=()
for vn in "${kVAR_NAMES[@]}"; do
  defVals+=( "${!vn}" )
done

# See if we support prefilling the edit buffer for the `read` builtin 
# - either with a native option in Bash 4+, or, if on OSX, which has Bash 3.x, with an 
#   AppleScript workaround.
[[ ${BASH_VERSINFO[0]} -ge 4 || $(uname) == 'Darwin' ]] && editBufferPrefillSupported=1 || editBufferPrefillSupported=0

# --- BEGIN: PROMPT USER

cat <<EOF
----------
You are about to INITIALIZE AN npm PACKAGE AND Git REPO, through a 
SERIES OF PROMPTS, named

  $(green "$vNAME"; isLegalNpmPackageName "$vNAME" || yellow <<EOF2

  WARNING: Package name '$vNAME' is not allowed in the npm registry.
           Unless you are creating a PRIVATE package, abort now, change the
           directory name to a legal name, and try again.
           Notably, uppercase characters are not allowed, the name must not
           start with a period or underscore, and may otherwise only contain
           URL-safe characters - see
           https://docs.npmjs.com/files/package.json\#name
EOF2
)

in the current directory:

  $(green "${PWD/#$HOME/~}")

- To change the package name, abort now, rename the directory, then reinvoke.
- Values that require explicit input are marked with (*).
- Default values are shown in [$(green brackets)]; for Booleans, the default is capitalized.
  - Specify '-' to suppress a default value.
  - Run \`$kTHIS_NAME -e\` to modify settings and default values.
Press ^C anytime to abort.
----------
EOF

pass=0
while :; do  # prompt loop - it is re-entered, if the user chooses to revise inputs at the end of all prompts

  (( ++pass ))

  i=0
  for (( i = 0; i < "${#kVAR_NAMES[@]}"; i++ )); do

    vn=${kVAR_NAMES[i]}
    # For certain package types: skip prompts selectively.
    contains "$vn" "${varPromptsToSkip[@]}" && continue
    hint=${kHINTS[i]}
    defVal=$(expandVars "${defVals[i]}")  # Note: some default values may require expansion, because they're derived from previous values.
    # See if an *edit-buffer* default value is defined.
    vn_EditBufDefault="${vn}_EDITBUFDEFAULT"
    defVal_EditBuf=${!vn_EditBufDefault}
    [[ $hint == *'(*)'* ]] && inputRequired=1 || inputRequired=0

    isBool=0 defValColored=
    if [[ $defVal =~ ^(true|false)$ ]]; then # BOOLEAN property.
      isBool=1
      if (( inputRequired && pass == 1 )); then
            # Strictly speaking, this is no default value, but we do want to display the choices for Booleans.       
            defVal='y/n'; defValColored=$defVal
      else
        [[ $defVal == 'true' ]] && 
          { defVal='Y/n'; defValColored="$(green 'Y')/n"; } ||
          { defVal='y/N'; defValColored="y/$(green 'N')"; }
      fi
    else # NON-Boolean property
      # if global installation is preferred, default to a CLI with the same name as the package.
      [[ $vn == 'vBIN_LIST' && $vPREFERGLOBAL == 'true' ]] && defVal=$vNAME
      # if global installation is preferred, do not provide a default'main' entry for global packages
      [[ $vn == 'vMAIN' && $vPREFERGLOBAL == 'true' ]] && defVal=
      [[ -n $defVal ]] && defValColored=$(green "$defVal")
    fi
    defValSuffix="${defVal:+ [}${defValColored}${defVal:+]}"
    valid=0
    while (( ! valid )); do
      # ---- Prompt the user.
      extraReadOpts=()
      if [[ -n $defVal_EditBuf && $editBufferPrefillSupported -eq 1 ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
          extraReadOpts=( -i "$defVal_EditBuf" )
        else # implies OSX (see above): use AppleScript workaround
          # Launch an AppleScript command in the background that sends the value as simulated keystrokes.
          # !! AS OF OSX 10.11.1, THE keystroke COMMAND IGNORES "." CHARS. AND DIGITS DUE TO A BUG.
          (osascript -e 'tell application "System Events" to keystroke "'"${defVal_EditBuf//\"/\\\"}"'"' &)
        fi
      fi
      # Read use input into variable $val.
      read -er -p "${hint}${defValSuffix}: " "${extraReadOpts[@]}" val
      [[ -n $val ]] && history -s "$val" # add to (session-only) history so that user can use readline features such as arrow-up to recall previous entries
      # ---
      if (( isBool )); then   # BOOLEAN
        if [[ -z $val ]] && (( ! inputRequired || pass > 1 )); then # no input provided, and either not required or already provided in a previous pass.
            # Use default value
            [[ $defVal == Y* ]] && val='y' || val='n'
        fi
        case "$val" in
          y|Y)
            val='true'
            valid=1
            ;;
          n|N)
            val='false'
            valid=1
            ;;
          *)
            errMsg='ERROR: TRY AGAIN: '
            [[ -z $val ]] && errMsg+='Type "y" or "n".' || errMsg+="Invalid input: $val"
            ;;
        esac
        if [[ $vn == 'vPRIVATE' ]]; then # private == do NOT publish to the npm registry.
          if [[ $val == 'false' ]]; then
            isLegalNpmPackageName "$vNAME" || die "Not a legal npm-registry package name: $vNAME"
          fi
        fi        
      else                     # NON-Boolean
        # Determine effective value by applying/suppressing the default value.
        if [[ $val == '-' ]]; then # '-' indicates that no value should be used at all (instead of the default value)
          val=
        else # Use value specified, and fall back on default, if none.
          val=${val:-$defVal}
        fi
        # *Validate (and possibly transform)* the resulting value.
        if [[ $vn == 'vBIN_LIST' ]]; then # Turn list of CLIs (binaries) into map (object).
          vBIN_MAP= vBIN_FIRST=
          if [[ -n $val ]]; then
            binArray=()
            IFS=, read -r -a clis <<<"$val"
            for cli in "${clis[@]}"; do
              read -r cli <<<"$cli" # trim surrounding whitespace
              [[ -z $vBIN_FIRST ]] && vBIN_FIRST=$cli  # save the name of the *1st* CLI - it's used in templating below to create a stub file for it.
              binArray+=( "\"${cli}\": \"bin/${cli}\"" ) 
            done
            vBIN_MAP=$(toJsonObject '    ' "${binArray[@]}")  # convert list to JSON object
            valid=1
          fi
        elif [[ $vn == 'vMAIN' ]]; then # Main JS module
          if [[ -n $val ]]; then
            # As a courtesy, let's add extension '.js', if not present.
            egrep -qi '\.js$' <<<"$val" || val+='.js'
            valid=1
          fi
        elif [[ $vn == 'vOS_LIST' ]]; then # list of supported / excluded OSs (platforms)
          vOS_ARRAY=() vOS_JSON_ARRAY=
          if [[ -n $val ]]; then
            negCount=0
            IFS=, read -r -a osIds <<<"$val"
            for osId in "${osIds[@]}"; do
              read -r osId <<<"$osId" # trim surrounding whitespace
              contains "${osId#!}" "${kOS_IDS[@]}"  || { errMsg="ERROR: TRY AGAIN: Not a valid OS identifier: $osId"; valid=0; break; }
              [[ $osId == '!'* ]] && (( ++negCount ))
              vOS_ARRAY+=( "$osId" ) # note: we use vOS_ARRAY in README.tmpl.md
              valid=1
            done
            if (( valid )); then
              if (( negCount > 0 && negCount != ${#osIds[@]} )); then
                errMsg="ERROR: TRY AGAIN: It makes no sense to both include and exclude OSs (including is not additive)."
                valid=0
              else
                vOS_JSON_ARRAY=$(toJsonArray '    ' "$val") # convert list to JSON array
              fi
            fi
          fi
        elif [[ $vn == 'vLIC_SPDX_ID' ]]; then # license
          if [[ -n $val ]]; then
            if [[ $val == *'!' ]]; then # forced use (via suffix '!') of a license ID that could not be validated.
              val=${val%!} # Note: by stripping the '!' now, validation will be reattempted if the user chooses to revise values - too exotic a use case to worry about...
              echoWarning 'Note: Forced use of unvalidated license ID.'
              valid=1
            else
              # Validate against the static list of license IDs read from the settings and obtain
              # the true case of the ID, because the URLs on the spdx.org site are case-SENSITIVE.
              valTrueCase=$(contains -ip "$val" "${vLIC_SPDX_IDs[@]}") && valid=1
              if (( valid )); then
                val=$valTrueCase
                vLIC_SPDX_ID=$valTrueCase # assign to official variable now, because expanding vLIC_URL in the next statement relies on it.
                licUrl=$(expandVars "$vLIC_URL")  # determine the URL to the license source text based on the value entered; !! do NOT re-assign to vLIC_URL *yet*, as that would break the ability to revise later.                
              fi
              (( valid )) || errMsg="'$val' is either not a valid SPDX license ID or needs to be added to the list of IDs in $kSETTINGS_FILE. To force its use, append '!' (e.g., 'MY_LIC!'). Check the link in 'LICENSE.md' afterward."
            fi
          fi
        elif [[ $vn == 'vKEYWORD_LIST' ]]; then
          vKEYWORD_LIST=$val
          vKEYWORD_ARRAY=
          if [[ ! (${val//,/} =~ ^[[:blank:]]*$) ]]; then # only create array if actual keywords were specified (not just whitespace or commas)
            vKEYWORD_ARRAY=$(toJsonArray '    ' "$vKEYWORD_LIST")
            valid=1
          fi
        else # other fields: no specific checks
          [[ -n $val ]] && valid=1
        fi
        # See if an *empty* value is allowed.
        if [[ -z $val ]]; then
          errMsg="ERROR: TRY AGAIN: A non-empty value is required."
          if [[ $vn == 'vMAIN' && $vPREFERGLOBAL == 'true' ]]; then # ok not to have a main module for global packages
            valid=1
          elif [[ $vn == 'vBIN_LIST' ]]; then
            [[ -n $vBIN_MAP || $vPREFERGLOBAL == 'false' ]] && valid=1 # ok not to have bin entries for non-global packages
          elif (( ! inputRequired )); then # input hint doesn't contain marker for required input
            valid=1
          fi
        fi
      fi
      (( valid )) || echoError "$errMsg"  # invalid input; print error message, then reprompt.
    done # while (( ! valid ))
    # Assign effective value to variable at hand - note the %s, which not only makes the command more robust, but is *required* if $val is *empty*.
    printf -v "$vn" %s "$val"
    defVals[i]=$val  # also reassign to the `defVals` array, in case the user opts to revise values by running through the prompts again
  done  # for

  # DERIVE ADDITIONAL VALUES THAT DEPEND ON VALUES THAT THE USER JUST ENTERED OR CONFIRMED.
  for vn in "${delayedExpansionVars[@]}"; do
    printf -v "$vn" '%s' "$(expandVars "${!vn}")"
  done

  # REMOVE INAPPLICABLE DEV. DEPENDENCIES based on chosen package type and global defaults.
  devDepsToRemove=()
  # - 'urchin' is only needed for CLI-only projects
  # - 'tap' is only needed for lib[+CLI] projects
  if [[ -n $vMAIN ]]; then
    devDepsToRemove+=( 'urchin' )  # i.e.: leave TAP
  else
    devDepsToRemove+=( 'tap' )     # i.e.: leave URCHIN
  fi
  # - 'marked-man' - for Markdown-to-man-page (ROFF) conversion - is only needed if vMAN_ON is set to true *and*
  #   a CLI exists.
  if [[ -z $vBIN_FIRST || $vMAN_ON != 'true' ]]; then
    devDepsToRemove+=( 'marked-man' )
  fi
  if (( ${#devDepsToRemove[@]} )); then
    for devDep in "${devDepsToRemove[@]}"; do
      vDEV_DEPENDENCIES=$(json -j -e "delete this[\"$devDep\"]" <<<"$vDEV_DEPENDENCIES") || die "Failed to remove unneeded dependencies from JSON array."
    done
  fi

  echoStatus "Generating 'package.json'..."

  # --- BEGIN: package.json TEMPLATE

  dq=\"  # helper variable for including literal double quotes in variable expansions - required, because literal " would be removed, and literal \" would be retained as-is.

  # Note re vMAN_ON: We only include the flag if it is true and the new package has a CLI *now*.
  #                  Leaving the flag on and only later adding a CLI would not work, because the prerequisites for man-page creation
  #                  will then not be met (no "man" property in package.json, no marked-man dependency installed - this is only ensured
  #                  if a CLI is defined *now*). Thus, adding a CLI later requires explicit use of `make toggle-man` to turn the feature on.

  IFS= read -d '' -r json <<EOF 
{
    "name": "$vNAME"
  , "description": "$vDESCR"
  , "private": $vPRIVATE
  , "version": "$vVERSION"
  ${vOS_JSON_ARRAY:+, ${dq}os${dq}:${vOS_JSON_ARRAY}}
  , "preferGlobal": $vPREFERGLOBAL
  ${vBIN_MAP:+, ${dq}bin${dq}:${vBIN_MAP}}
  $( [[ $vMAN_ON == 'true' && -n $vBIN_FIRST ]] && echo ", \"man\": \"./man/${vBIN_FIRST}.1\"" )
  ${vMAIN:+, ${dq}main${dq}: ${dq}lib/${vMAIN}${dq}}
  , "homepage": "$vHOMEPAGE"
  , "repository":
    {
        "type": "git"
      , "url": "$vREPO_URL"
    }
  , "bugs":
    {
        "url": "$vBUGS_URL"
    }
  , "scripts":$(toJsonObject '    ' "${vPACKAGE_SCRIPTS[@]}")
  , "keywords":${vKEYWORD_ARRAY}
  , "author": "$vAUTHOR"
  ${vLIC_SPDX_ID:+, ${dq}license${dq}: ${dq}${vLIC_SPDX_ID}${dq}}
  , "net_same2u": { "make_pkg": { "tocOn": $vTOC_ON, "tocTitle": "$vTOC_TITLE"$( [[ -n $vBIN_FIRST && $vMAN_ON == 'true' ]] && echo ", \"manOn\": $vMAN_ON" ) } }
  , "devDependencies":
    $(sed '2,$ s/^/    /' <<<"$vDEV_DEPENDENCIES")
}
EOF

  # --- END: package.json TEMPLATE

cat <<EOF
$json
-------
$(echoStatus "Write the above to 'package.json' and proceed?")
------
EOF

  proceed=0
  while :; do
    read -er -p '(Y)es, (r)evise, (a)bort [y/r/a]? '
    [[ $REPLY =~ ^[yY]$ ]] && { proceed=1; break; } # OK
    [[ $REPLY =~ ^[aA]$ ]] && { echoError "Aborted."; exit 3; }
    [[ $REPLY =~ ^[rR]$ ]] && { break; }
    echoError "Invalid input; please try again ('a' or ^C to abort)."
  done

  (( proceed )) && break # confirmed

  # Otherwise: run through prompts again

done
# --- END: PROMPT USER

# Determine the set of all preexisting files, if any.
preexistingFiles=$(find . -type f | cut -d '/' -f2- | sort)

# Create package.json
printf %s "$json" > 'package.json' || die
echoStatus '-- package.json created.'


# Note: We copy 'Makefile' from this utility's own *root* package folder, as that is the designated master copy - it is used by this utility package itself - no need to duplicate it in ./templates/.
[[ -f ./Makefile ]] && echo "(Existing file preserved: $PWD/Makefile)" >&2 || { cp "$kTEMPLATE_FOLDER/../Makefile" . || die "Failed to copy Makefile."; }

# Save a list of all files comprising the core template.
coreTemplateFiles=$(find "$kTEMPLATE_FOLDER" -type f | awk -F "^$kTEMPLATE_FOLDER/" '{ print $2 }' | sort)

# Determine the set of template folders to copy
  # Core templates
tmplDirs=( "$kTEMPLATE_FOLDER" )
if [[ -n $pkgType ]]; then
  tmplDirs+=( "${kTEMPLATE_FOLDER}.${pkgType}" )
else # no package type specified: this means tha FULL set of prompts, and a package that may contain BOTH a (JS) library file AND a CLI.
    # If the package (also) has a JS module, also include the (JS) LIBRARY templates.
  [[ -n $(json -f package.json main) ]] && tmplDirs+=( "${kTEMPLATE_FOLDER}.lib" )
    # If the package (also) has CLIs, also include the CLI templates.
  [[ -n $(json -f package.json bin) ]] && tmplDirs+=( "${kTEMPLATE_FOLDER}.cli" )
fi

for tmplDir in "${tmplDirs[@]}"; do
  # Copy all template files (both true templates that need expansion (e.g., README.tmpl.md) and files to be copied 'as is', (e.g., ./test/*)), without overwriting any existing files (-n).
  # Note: By copying template files BEFORE `npm install`, we avoid npm's warning about a missing read-me.
  #       Copying is recursive, but doesn't replace any existing files.
  (shopt -s dotglob; cp -R -n "$tmplDir"/* .) || { (( isDirEmpty )) && die "Failed to copy template files."; } # !! with -n (no clobbering), if files are skipped during copying, cp apparently invariably sets exit code 1.
  # Additionally: if a specific template is trying to overwrite core template files, which we *do* want, we must do this 
  #               *explicitly*, given that `cp -n` above preserved all existing files, including the ones copied by the core template.
  if [[ $tmplDir != "$kTEMPLATE_FOLDER" ]]; then # this is a NON-core template
    # Check for overlap in files between this and the core template.
    thisTemplateFiles=$(find "$tmplDir" -type f | awk -F "^$tmplDir/" '{ print $2 }' | sort)
    overlappingFiles=$(comm -12 <(printf '%s\n' "$coreTemplateFiles") <(printf '%s\n' "$thisTemplateFiles"))
    # Loop over overlapping files and copy them, unless they were among the *preexisting* files.
    while IFS= read -r f; do
      if ! grep -q -F "$f" <<<"$preexistingFiles"; then
        cp "$tmplDir/$f" "$f" || die "Failed to copy template file: $tmplDir/$f"
      fi
    done <<<"$overlappingFiles"
  fi
done

# Determine if a Git repo is already present.
[[ -d .git ]] && alreadyHasGitRepo=1 || alreadyHasGitRepo=0

# Rename '_gitignore.mustrename' to '.gitignore'.
# Note that the npm registry doesn't include .gitignore files when installing packages; rather
# than fiddling with exceptions via .npmignore, we give .gitignore a different name in the template
# and then rename it on package initialization.
proxyGitIgnoreFilename='_gitignore.mustrename'
[[ -f .gitignore ]] && { rm "$proxyGitIgnoreFilename"; echo "(Existing .gitignore file preserved.)" >&2; } || { mv "$proxyGitIgnoreFilename" .gitignore || die "Failed to create .gitignore file."; }

# The package-type-specific template files may comprise .git hooks, located in
# .git/hooks/.
# Again, a proxy name had to be used, which must now be changed to '.git'.
# Note that prepopulating .git/hooks/ does NOT cause a problem when later
# running `git init`.
proxyGitDirName='_git.mustrename'
if [[ -d $proxyGitDirName ]]; then
  # Only install the hooks if there's no repo yet (a blanket warning will be issued below).
  (( alreadyHasGitRepo )) && { rm -rf "$proxyGitDirName"; } || { mv "$proxyGitDirName" .git || die "Failed to create .git directory."; }
fi

# Now expand all true template files (-O), without overwriting any existing target files (-n), and delete the template files afterward (-d).
# Note that our templates contains *command substitutions* such as '$(date +%Y)', so we canNOT use -s to restrict expansions to only *variable* references.
expandTemplate -Ond "$PWD" >/dev/null || die

echoStatus '-- Template files copied and expanded.'

# Install npm dependencies.
echoStatus '-- Installing development npm dependencies ...' # since this can take a while, report the *start* of the operation
npm install >/dev/null || die

# Git-related actions
if (( alreadyHasGitRepo )); then

  echoWarning 'WARNING: Existing Git repo found; no Git-related actions taken.'

else

  # Initialize the local Git repo (but don't add or commit anything yet).
  git init >/dev/null || die
  echoStatus '-- Local Git repository initialized.'

  # Define the remote repo counterpart.
  git remote add origin "$vREPO_URL" || die
  echoStatus '-- Remote origin repository defined.'

  if [[ $localOnly -eq 1 ]]; then
    echoStatus '(Skipping creation of remote repository on GitHub, as requested.)'
  elif [[ -z vGITHUB_TOKEN ]]; then
    echoWarning "Cannot create repository on GitHub, due to missing authorization token."
  else
    # Create the remote counterpart repo on GitHub, using the GitHub API.
    # If this fails, we let createGhRepo issue an error message, but don't abort.
    createGhRepo "$vGITHUB_USERNAME" "$vGITHUB_TOKEN" "$vNAME" "$vDESCR" &&
      echoStatus "-- Remote GitHub repository '$vGITHUB_USERNAME/$vNAME' created." ||
      echoWarning "-- WARNING: Remote GitHub repository '$vGITHUB_USERNAME/$vNAME' NOT created."
  fi

fi

cat <<EOF
---------
$(green "Package '$vNAME' SUCCESSFULLY INITIALIZED.")
 - To add npm packages later:
   - for run-time use: npm install <pkg> --save
   - for dev use only: npm install <pkg> --save-dev
 - Add tests to the './test' subdirectory.
 - Run \`make list\` to see available makefile tasks.
 - Run \`make push\` to push to the remote GitHub repo.
 - Run \`make verinfo\` to see the current package version.
 - To have version numbers in source files automatically updated
   with \`make version VER=...\` and \`make release VER=...\`,
   ensure that the files initially contain 'v$vVERSION' - *with* the 'v'.
 - For more information, visit $kTHIS_HOMEPAGE
---------
EOF

# Invoke a post-initialization command, if specified.
if [[ -n $vPOSTINIT_CMD ]]; then
  "${vPOSTINIT_CMD[@]}"
fi

####
# MAN PAGE MARKDOWN SOURCE
#  - Place a Markdown-formatted version of the man page for this script
#    inside the here-document below.
#    The document must be formatted to look good in all 3 viewing scenarios:
#     - as a man page, after conversion to ROFF with marked-man
#     - as plain text (raw Markdown source)
#     - as HTML (rendered Markdown)
#  Markdown formatting tips:
#   - GENERAL
#     To support plain-text rendering in the terminal, limit all lines to 80 chars.,
#     and, for similar rendering as HTML, *end every line with 2 trailing spaces*.
#   - HEADINGS
#     - For better plain-text rendering, leave an empty line after a heading
#       marked-man will remove it from the ROFF version.
#     - The first heading must be a level-1 heading containing the utility
#       name and very brief description; append the manual-section number 
#       directly to the CLI name; e.g.:
#         # foo(1) - does bar
#     - The 2nd, level-2 heading must be '## SYNOPSIS' and the chapter's body
#       must render reasonably as plain text, because it is printed to stdout
#       when  `-h`, `--help` is specified:
#         Use 4-space indentation without markup for both the syntax line and the
#         block of brief option descriptions; represent option-arguments and operands
#         in angle brackets; e.g., '<foo>'
#     - All other headings should be level-2 headings in ALL-CAPS.
#   - TEXT
#      - Use NO indentation for regular chapter text; if you do, it will 
#        be indented further than list items.
#      - Use 4-space indentation, as usual, for code blocks.
#      - Markup character-styling markup translates to ROFF rendering as follows:
#         `...` and **...** render as bolded (red) text
#         _..._ and *...* render as word-individually underlined text
#   - LISTS
#      - Indent list items by 2 spaces for better plain-text viewing, but note
#        that the ROFF generated by marked-man still renders them unindented.
#      - End every list item (bullet point) itself with 2 trailing spaces too so
#        that it renders on its own line.
#      - In items representing CLI options, use `...` styling, with option-arguments
#        in angle brackets; e.g. (don't forget 2 trailing spaces):
#          * `-h, --help`
#          * `-f, --file <file>`
#      - Avoid associating more than 1 paragraph with a list item, if possible,
#        because it requires the following trick, which hampers plain-text readability:
#        Use '&nbsp;<space><space>' in lieu of an empty line.
####
: <<'EOF_MAN_PAGE' # DO NOT ALTER THIS LINE.
# make-pkg(1) - initialize and maintain npm package projects

## SYNOPSIS

Initializes an npm-package project in the current directory and  
implements a maintenance and release workflow.
    
    make-pkg [-l] [-f] [<pkg-type>]
    make-pkg -e

    -l            suppresses creation of remote repo on GitHub
    -f            forces running in a non-empty directory
    -e            opens the settings file for editing

    <pkg-type>    [experimental] creates a specific package type:
                  'lib': JS library (only)
                  'cli': CLI (only), global installation preferred
                  'awf': an Alfred 2 workflow

Standard options: `--help`, `--man`, `--version`, `--home`

## DESCRIPTION

Initializes a GitHub-based npm-package project in the current directory and  
implements a maintenance and release workflow based on Makefile tasks.
 
To create a new package project:

  * create a directory for it
  * change to that directory
  * run `make-pkg` there.

On first run you'll be prompted for settings, including creation of a GitHub  
authorization token.

Not specifying `<pkg-type>` presents the full set of prompts for creating a
a library and/or CLI npm package.  
Package types other than 'lib' and 'cli' offer additional, type-specific  
features.

In addition to initializing package-configuration file 'package.json'  
through a series of prompts, this utility:

  * initializes a local Git repository, adds a .gitignore file, and defines  
    the remote 'origin' repo.
  * creates a matching remote repository on GitHub.
  * instantiates several template files so as to provide a starting point for  
    a read-me file, license file, ...
  * installs stubs for the main module, the CLI, if applicable, and tests.  
  * installs npm dev dependencies for managing the new package.
  * installs a Makefile with a set of tasks for releasing and maintaining the  
    package.

Run `make list` in a package folder to see a list of all Makefile tasks.

While this utility is typically used to create packages intended for  
publication via the npm registry (https://www.npmjs.com/), it can be used to  
manage GitHub-based OSS projects in general.

For more information, visit https://github.com/mklement0/make-pkg

## OPTIONS

 * `-l`  
  Local processing only: no attempt is made to create a matching  
  repository on GitHub.

 * `-f`  
  Forces execution in the current directory, even if it is not empty.  
  Note that existing files, including a Git repository, are left untouched,  
  'package.json' being the only exception.

 * `-e`  
    Opens this utility's settings file, `~/.make-pkg-rc`, for editing.


## STANDARD OPTIONS

All standard options provide information only.

 * `-h, --help`  
    Prints the contents of the synopsis chapter to stdout for quick reference.

 * `--man`  
    Displays this manual page, which is a helpful alternative to using `man`, 
    if the manual page isn't installed.

 * `--version`  
    Prints version information.
    
 * `--home`  
    Opens this utility's home page in the system's default web browser.

## LICENSE

For license information and more, visit this utility's home page by running  
`make-pkg --home`.

EOF_MAN_PAGE
